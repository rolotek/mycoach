---
phase: 06-api-key-management
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - apps/server/src/llm/providers.ts
  - apps/server/src/trpc/router.ts
autonomous: true

must_haves:
  truths:
    - "tRPC apiKey.save stores encrypted key and validates against provider API"
    - "tRPC apiKey.list returns provider+status (never raw keys)"
    - "tRPC apiKey.delete removes a stored key"
    - "getUserModel creates a per-request provider instance with user's decrypted API key"
    - "getUserModel falls back to env var keys when user has no custom key"
    - "tRPC agent.update accepts optional preferredModel field"
  artifacts:
    - path: "apps/server/src/llm/providers.ts"
      provides: "getUserModel function for per-user provider instances, resolveUserModel for full resolution"
      exports: ["getUserModel", "resolveUserModel"]
    - path: "apps/server/src/trpc/router.ts"
      provides: "apiKey router with save/list/delete, agent update with preferredModel, settings update with monthlyBudgetCents"
      contains: "apiKeyRouter"
  key_links:
    - from: "apps/server/src/trpc/router.ts"
      to: "apps/server/src/crypto/encryption.ts"
      via: "encrypt/decrypt for API key storage"
      pattern: "encrypt\\(|decrypt\\("
    - from: "apps/server/src/llm/providers.ts"
      to: "@ai-sdk/anthropic"
      via: "createAnthropic({ apiKey })"
      pattern: "createAnthropic"
    - from: "apps/server/src/llm/providers.ts"
      to: "@ai-sdk/openai"
      via: "createOpenAI({ apiKey })"
      pattern: "createOpenAI"
    - from: "apps/server/src/trpc/router.ts"
      to: "apps/server/src/llm/providers.ts"
      via: "key validation uses provider APIs"
      pattern: "validateApiKey"
---

<objective>
Build the API key management tRPC routes (save/list/delete with encryption and validation) and the per-user model resolution function that creates dynamic provider instances using decrypted user keys.

Purpose: This connects the encrypted key storage to the LLM layer. Without these routes, users cannot manage keys. Without getUserModel, the chat route cannot use per-user keys.
Output: Working tRPC apiKey router, updated providers.ts with getUserModel/resolveUserModel.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-api-key-management-usage-tracking-users-can-set-individual-api-keys-for-anthropic-openai-select-models-track-token-usage-and-monitor-spending-against-budgets-using-provider-billing-apis/06-01-SUMMARY.md
@apps/server/src/trpc/router.ts
@apps/server/src/llm/providers.ts
@apps/server/src/llm/registry.ts
@apps/server/src/crypto/encryption.ts
@apps/server/src/db/schema.ts
@.planning/phases/06-api-key-management-usage-tracking-users-can-set-individual-api-keys-for-anthropic-openai-select-models-track-token-usage-and-monitor-spending-against-budgets-using-provider-billing-apis/06-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getUserModel and resolveUserModel to providers.ts</name>
  <files>apps/server/src/llm/providers.ts</files>
  <action>
Modify `apps/server/src/llm/providers.ts` to add two new exported functions while keeping existing `getModel`, `chat`, `chatStream`, `getAvailableProviders` intact:

1. `getUserModel(provider: string, modelId: string, apiKey: string)`:
   - Import `createAnthropic` from `@ai-sdk/anthropic` and `createOpenAI` from `@ai-sdk/openai`
   - Switch on provider:
     - `"anthropic"`: `const anthropic = createAnthropic({ apiKey }); return anthropic(modelId);`
     - `"openai"`: `const openai = createOpenAI({ apiKey }); return openai(modelId);`
     - default: throw Error `Unsupported provider for user keys: ${provider}`
   - Note: modelId here is the RAW model ID (e.g., "claude-sonnet-4-20250514"), NOT the prefixed format ("anthropic:claude-sonnet-4-20250514")

2. `resolveUserModel(userId: string, agentPreferredModel?: string | null)`:
   - Import `db` from `../db`, `userSettings` and `userApiKeys` from `../db/schema`, `decrypt` from `../crypto/encryption`
   - This function resolves the model to use for a given user, with fallback chain:
     a. If `agentPreferredModel` is provided (format: "provider:model"), use it
     b. Otherwise, fetch user's `userSettings.preferredModel`
     c. Fallback: `process.env.COACH_CHAT_MODEL ?? "ollama:${process.env.OLLAMA_MODEL || 'llama3.1'}"`
   - Parse the resolved model string to extract `provider` and `modelName` by splitting on first `:`
   - If provider is "anthropic" or "openai":
     - Fetch the user's API key from `userApiKeys` where userId and provider match
     - If key exists: decrypt it, return `{ model: getUserModel(provider, modelName, decryptedKey), provider, modelName, usingUserKey: true }`
     - If no key: fall back to `getModel(prefixedModelId)` (env var key), return `{ model: getModel(prefixedModelId), provider, modelName, usingUserKey: false }`
   - If provider is "ollama" or other: use `getModel(prefixedModelId)`, return `{ model: getModel(prefixedModelId), provider, modelName, usingUserKey: false }`
   - Return type: `{ model: LanguageModel; provider: string; modelName: string; usingUserKey: boolean }`
   - Import `LanguageModel` from `ai` for the return type

3. Add `validateApiKey(provider: string, apiKey: string): Promise<boolean>`:
   - For "anthropic": fetch `https://api.anthropic.com/v1/models?limit=1` with headers `x-api-key: apiKey` and `anthropic-version: 2023-06-01`. Return `res.ok`.
   - For "openai": fetch `https://api.openai.com/v1/models` with header `Authorization: Bearer ${apiKey}`. Return `res.ok`.
   - Wrap in try/catch, return false on network errors.
   - Export this function (used by tRPC route).
  </action>
  <verify>
Run `cd /Users/allenwong/Workspace/mycoach && npm run type-check` -- should pass.
  </verify>
  <done>providers.ts exports getUserModel, resolveUserModel, and validateApiKey. getModel still works for system-level calls. resolveUserModel implements the full fallback chain: agent model -> user settings -> env var, with per-user key decryption for anthropic/openai.</done>
</task>

<task type="auto">
  <name>Task 2: Add apiKey tRPC router and update agent/settings schemas</name>
  <files>apps/server/src/trpc/router.ts</files>
  <action>
Modify `apps/server/src/trpc/router.ts`:

1. Import `userApiKeys` from `../db/schema` (add to existing import)
2. Import `encrypt, decrypt` from `../crypto/encryption`
3. Import `validateApiKey` from `../llm/providers`

4. Create `apiKeyRouter` with three procedures:
   - `save`: protectedProcedure
     - Input: `{ provider: z.enum(["anthropic", "openai"]), apiKey: z.string().min(10) }`
     - Validate the key by calling `validateApiKey(provider, apiKey)`
     - If invalid, throw TRPCError `BAD_REQUEST` with message "Invalid API key -- could not authenticate with provider"
     - Encrypt: `const encryptedKey = encrypt(apiKey)`
     - Upsert into `userApiKeys`: use `onConflictDoUpdate` on the unique constraint (userId, provider), updating `encryptedKey`, `isValid: true`, `lastValidatedAt: new Date()`, `updatedAt: new Date()`
     - Return `{ success: true, provider }`

   - `list`: protectedProcedure
     - Query all userApiKeys where userId matches
     - Return array of `{ id, provider, isValid, lastValidatedAt, createdAt }` -- NEVER return encryptedKey or decrypted key
     - Map results to add a `maskedKey` field: decrypt the key, take first 7 chars + "..." + last 4 chars (e.g., "sk-ant-...xYz1")

   - `delete`: protectedProcedure
     - Input: `{ provider: z.enum(["anthropic", "openai"]) }`
     - Delete from userApiKeys where userId and provider match
     - Return `{ success: true }`

5. Update `agentRouter.update` input schema:
   - Add `preferredModel: z.string().max(100).nullable().optional()` to the input
   - In the update handler, if `input.preferredModel !== undefined`, set `updates.preferredModel = input.preferredModel`

6. Register the apiKey router in `appRouter`:
   - Add `apiKey: apiKeyRouter` to the appRouter

7. Verify the settingsRouter.update already handles the new `monthlyBudgetCents` field (it uses the shared schema and spreads `...input`, so it should work automatically since we updated the shared schema in 06-01).
  </action>
  <verify>
Run `cd /Users/allenwong/Workspace/mycoach && npm run type-check` -- should pass.
  </verify>
  <done>apiKey.save validates keys against provider API, encrypts, and upserts. apiKey.list returns masked keys without exposing raw values. apiKey.delete removes stored keys. agent.update accepts preferredModel. All registered in appRouter.</done>
</task>

</tasks>

<verification>
- `npm run type-check` passes from repo root
- apiKey router registered in appRouter with save/list/delete
- providers.ts exports getUserModel, resolveUserModel, validateApiKey
- agent update accepts preferredModel
</verification>

<success_criteria>
tRPC apiKey routes work end-to-end (save encrypts + validates, list masks, delete removes). resolveUserModel implements fallback chain: agent model -> user default -> env var. Per-user provider instances created with decrypted keys.
</success_criteria>

<output>
After completion, create `.planning/phases/06-api-key-management-usage-tracking-users-can-set-individual-api-keys-for-anthropic-openai-select-models-track-token-usage-and-monitor-spending-against-budgets-using-provider-billing-apis/06-02-SUMMARY.md`
</output>
