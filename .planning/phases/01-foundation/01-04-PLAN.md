---
phase: 01-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - apps/web/src/lib/auth-client.ts
  - apps/web/src/lib/trpc.ts
  - apps/web/src/providers/index.tsx
  - apps/web/src/app/layout.tsx
  - apps/web/src/app/page.tsx
  - apps/web/src/app/(auth)/login/page.tsx
  - apps/web/src/app/(auth)/signup/page.tsx
  - apps/web/src/app/(app)/dashboard/page.tsx
  - apps/web/src/app/(app)/settings/page.tsx
  - apps/web/src/app/(app)/layout.tsx
  - apps/web/src/components/auth-guard.tsx
  - apps/web/package.json
  - apps/web/src/app/globals.css
autonomous: false
user_setup:
  - service: google-oauth
    why: "Google OAuth login (AUTH-03)"
    env_vars:
      - name: GOOGLE_CLIENT_ID
        source: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client IDs"
      - name: GOOGLE_CLIENT_SECRET
        source: "Same location as GOOGLE_CLIENT_ID"
    dashboard_config:
      - task: "Create OAuth 2.0 Client ID (Web application type)"
        location: "Google Cloud Console -> APIs & Services -> Credentials"
      - task: "Add authorized redirect URI: http://localhost:3001/api/auth/callback/google"
        location: "Same credentials page -> Authorized redirect URIs"
  - service: microsoft-oauth
    why: "Microsoft OAuth login (AUTH-04)"
    env_vars:
      - name: MICROSOFT_CLIENT_ID
        source: "Azure Portal -> App registrations -> Application (client) ID"
      - name: MICROSOFT_CLIENT_SECRET
        source: "Azure Portal -> App registrations -> Certificates & secrets"
    dashboard_config:
      - task: "Register application in Azure AD"
        location: "Azure Portal -> Azure Active Directory -> App registrations"
      - task: "Add redirect URI: http://localhost:3001/api/auth/callback/microsoft"
        location: "Azure Portal -> App registrations -> Authentication -> Redirect URIs"
      - task: "Set Supported account types to 'Accounts in any organizational directory and personal Microsoft accounts'"
        location: "Azure Portal -> App registrations -> Authentication"

must_haves:
  truths:
    - "User can visit /signup, enter email/password/name, and create an account"
    - "User can visit /login, enter email/password, and log in"
    - "User can click 'Sign in with Google' and authenticate via OAuth"
    - "User can click 'Sign in with Microsoft' and authenticate via OAuth"
    - "After login, user is redirected to /dashboard"
    - "Refreshing the browser on /dashboard does NOT require re-login (session persists)"
    - "Unauthenticated user visiting /dashboard is redirected to /login"
    - "User can visit /settings and select a preferred LLM provider and model"
    - "Settings are saved per-user and persist across page refresh"
    - "User A cannot see User B's settings"
  artifacts:
    - path: "apps/web/src/lib/auth-client.ts"
      provides: "Better Auth client instance"
      exports: ["authClient"]
    - path: "apps/web/src/lib/trpc.ts"
      provides: "tRPC React client"
      exports: ["trpc"]
    - path: "apps/web/src/app/(auth)/login/page.tsx"
      provides: "Login page with email/password + OAuth buttons"
    - path: "apps/web/src/app/(auth)/signup/page.tsx"
      provides: "Signup page with email/password form"
    - path: "apps/web/src/app/(app)/settings/page.tsx"
      provides: "Settings page with provider/model selection"
    - path: "apps/web/src/components/auth-guard.tsx"
      provides: "Client component that redirects unauthenticated users"
      exports: ["AuthGuard"]
  key_links:
    - from: "apps/web/src/lib/auth-client.ts"
      to: "apps/server /api/auth/*"
      via: "Better Auth client HTTP calls"
      pattern: "createAuthClient.*baseURL"
    - from: "apps/web/src/lib/trpc.ts"
      to: "apps/server /trpc/*"
      via: "tRPC httpBatchLink"
      pattern: "httpBatchLink.*url.*trpc"
    - from: "apps/web/src/app/(app)/settings/page.tsx"
      to: "trpc.settings.update"
      via: "tRPC mutation"
      pattern: "trpc.*settings.*update.*mutate"
    - from: "apps/web/src/components/auth-guard.tsx"
      to: "authClient.useSession()"
      via: "Session check + redirect"
      pattern: "useSession.*redirect"
---

<objective>
Build the frontend authentication flow and settings UI. Users can sign up, log in (email/password + Google/Microsoft OAuth), see a dashboard, and configure their preferred LLM provider and model. Session persists across browser refresh. Unauthenticated users are redirected to login. After this plan, all Phase 1 requirements are implemented end-to-end.

Purpose: This is the user-facing layer that makes authentication and LLM configuration accessible. Without it, auth and LLM are server-only capabilities.
Output: Working login, signup, dashboard, and settings pages connected to the backend.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Auth client + tRPC client + provider setup + auth guard</name>
  <files>
    apps/web/src/lib/auth-client.ts
    apps/web/src/lib/trpc.ts
    apps/web/src/providers/index.tsx
    apps/web/src/app/layout.tsx
    apps/web/src/components/auth-guard.tsx
    apps/web/src/app/globals.css
    apps/web/package.json
  </files>
  <action>
    1. **Install frontend dependencies** in apps/web:
       ```bash
       cd apps/web && npm install @trpc/client @trpc/tanstack-react-query @tanstack/react-query better-auth
       ```

    2. **apps/web/src/lib/auth-client.ts**: Better Auth client:
       ```typescript
       import { createAuthClient } from "better-auth/react";

       export const authClient = createAuthClient({
         baseURL: process.env.NEXT_PUBLIC_SERVER_URL || "http://localhost:3001",
       });
       ```
       NOTE: Use `better-auth/react` for React hooks integration (`useSession`). The `baseURL` points to the Hono server, NOT the Next.js app. Must be `NEXT_PUBLIC_` prefixed for client-side access.

    3. **apps/web/src/lib/trpc.ts**: tRPC React client:
       ```typescript
       import { createTRPCReact } from "@trpc/tanstack-react-query";
       import type { AppRouter } from "@mycoach/server/src/trpc/router";

       export const trpc = createTRPCReact<AppRouter>();
       ```
       NOTE: The type import path may need adjustment based on how Plan 01 configured the shared package exports. If direct import from @mycoach/server doesn't work, export AppRouter type from @mycoach/shared instead.

    4. **apps/web/src/providers/index.tsx**: Client-side providers wrapper:
       ```typescript
       "use client";
       import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
       import { httpBatchLink } from "@trpc/client";
       import { trpc } from "../lib/trpc";
       import { useState } from "react";

       export function Providers({ children }: { children: React.ReactNode }) {
         const [queryClient] = useState(() => new QueryClient());
         const [trpcClient] = useState(() =>
           trpc.createClient({
             links: [
               httpBatchLink({
                 url: `${process.env.NEXT_PUBLIC_SERVER_URL || "http://localhost:3001"}/trpc`,
                 fetch(url, options) {
                   return fetch(url, { ...options, credentials: "include" });
                 },
               }),
             ],
           })
         );

         return (
           <trpc.Provider client={trpcClient} queryClient={queryClient}>
             <QueryClientProvider client={queryClient}>
               {children}
             </QueryClientProvider>
           </trpc.Provider>
         );
       }
       ```
       CRITICAL: `credentials: "include"` in the fetch override. Without this, session cookies won't be sent to the Hono server (different port = cross-origin).

    5. **apps/web/src/app/layout.tsx**: Update root layout to wrap in Providers:
       ```tsx
       import { Providers } from "../providers";
       import "./globals.css";

       export const metadata = { title: "MyCoach" };

       export default function RootLayout({ children }: { children: React.ReactNode }) {
         return (
           <html lang="en">
             <body>
               <Providers>{children}</Providers>
             </body>
           </html>
         );
       }
       ```

    6. **apps/web/src/components/auth-guard.tsx**: Client component that checks session and redirects:
       ```tsx
       "use client";
       import { authClient } from "../lib/auth-client";
       import { useRouter } from "next/navigation";
       import { useEffect } from "react";

       export function AuthGuard({ children }: { children: React.ReactNode }) {
         const { data: session, isPending } = authClient.useSession();
         const router = useRouter();

         useEffect(() => {
           if (!isPending && !session) {
             router.replace("/login");
           }
         }, [session, isPending, router]);

         if (isPending) return <div>Loading...</div>;
         if (!session) return null;
         return <>{children}</>;
       }
       ```

    7. **apps/web/src/app/globals.css**: Import Tailwind:
       ```css
       @import "tailwindcss";
       ```

    8. Add `NEXT_PUBLIC_SERVER_URL=http://localhost:3001` to `.env.example` and `.env` in the project root (or in apps/web/.env.local).
  </action>
  <verify>
    - `cd apps/web && npm run build` compiles without TypeScript errors
    - Auth client can be imported: `import { authClient } from "@/lib/auth-client"`
    - tRPC client can be imported: `import { trpc } from "@/lib/trpc"`
    - Providers wrapper renders without errors in browser
  </verify>
  <done>
    Auth client, tRPC client, QueryClient provider, and AuthGuard component are wired up. The frontend can communicate with the Hono server for both auth and tRPC calls with session cookies included.
  </done>
</task>

<task type="auto">
  <name>Task 2: Login, signup, dashboard, and settings pages</name>
  <files>
    apps/web/src/app/(auth)/login/page.tsx
    apps/web/src/app/(auth)/signup/page.tsx
    apps/web/src/app/(app)/layout.tsx
    apps/web/src/app/(app)/dashboard/page.tsx
    apps/web/src/app/(app)/settings/page.tsx
    apps/web/src/app/page.tsx
  </files>
  <action>
    1. **Route structure**: Use Next.js route groups:
       - `(auth)` group: `/login`, `/signup` — public pages, no auth guard
       - `(app)` group: `/dashboard`, `/settings` — protected pages, wrapped in AuthGuard

    2. **apps/web/src/app/(auth)/login/page.tsx**: Login page with:
       - Email + password form (controlled inputs)
       - On submit: `authClient.signIn.email({ email, password })`. On success, redirect to `/dashboard`. On error, show inline error message.
       - "Sign in with Google" button: `authClient.signIn.social({ provider: "google", callbackURL: "/dashboard" })`
       - "Sign in with Microsoft" button: `authClient.signIn.social({ provider: "microsoft", callbackURL: "/dashboard" })`
       - Link to `/signup` at bottom
       - Style with Tailwind: centered card layout, max-w-md, clean form inputs, primary button style
       - Mark as `"use client"` (uses hooks)

    3. **apps/web/src/app/(auth)/signup/page.tsx**: Signup page with:
       - Name, email, password form (controlled inputs)
       - On submit: `authClient.signUp.email({ email, password, name })`. On success, redirect to `/dashboard`. On error, show inline error message.
       - Link to `/login` at bottom
       - Same styling as login
       - Mark as `"use client"`

    4. **apps/web/src/app/(app)/layout.tsx**: Protected layout:
       ```tsx
       import { AuthGuard } from "../../components/auth-guard";

       export default function AppLayout({ children }: { children: React.ReactNode }) {
         return <AuthGuard>{children}</AuthGuard>;
       }
       ```
       This means ALL pages under `(app)/` require authentication.

    5. **apps/web/src/app/(app)/dashboard/page.tsx**: Simple dashboard:
       - Display "Welcome, {user.name}" using `authClient.useSession()`
       - Show user email
       - "Sign out" button: `authClient.signOut()` then redirect to `/login`
       - Link to `/settings`
       - Mark as `"use client"`

    6. **apps/web/src/app/(app)/settings/page.tsx**: Settings page with LLM configuration:
       - Fetch current settings: `trpc.settings.get.useQuery()`
       - Fetch available providers: `trpc.llm.listProviders.useQuery()`
       - Provider selector: dropdown listing providers (Anthropic, OpenAI, Ollama)
       - Model selector: dropdown listing models for selected provider (cascading — changes when provider changes)
       - Save button: `trpc.settings.update.useMutation()` with selected provider + model
       - Show success/error feedback after save
       - Back link to `/dashboard`
       - Mark as `"use client"`

    7. **apps/web/src/app/page.tsx**: Update root page to redirect:
       - If session exists, redirect to `/dashboard`
       - If no session, redirect to `/login`
       - Use client-side redirect via `authClient.useSession()` + `useRouter()`

    8. Style all pages with Tailwind utility classes. Keep it clean and functional -- no custom design system needed. Neutral colors, good spacing, accessible form labels.
  </action>
  <verify>
    - Start both servers: `npm run dev` from root
    - Visit http://localhost:3000 → redirects to /login
    - Fill signup form → account created → redirected to /dashboard showing "Welcome, {name}"
    - Refresh browser on /dashboard → still logged in (session persists, AUTH-02)
    - Click sign out → redirected to /login
    - Log back in with email/password → works
    - Visit /settings → shows provider/model dropdowns
    - Select a different model → click save → refresh page → selection persists
    - Open incognito window, visit /dashboard → redirected to /login (can't see other user's dashboard)
    - If Google/Microsoft OAuth env vars are set: click "Sign in with Google" → OAuth flow works
  </verify>
  <done>
    Login, signup, dashboard, and settings pages are all functional. Email/password auth works end-to-end. OAuth buttons are present (functional when env vars configured). Session persists across browser refresh. Settings page allows selecting LLM provider and model, saved per-user. Unauthenticated users are redirected to login.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify Phase 1 end-to-end</name>
  <files>none (verification only)</files>
  <action>
    Human verifies the complete Phase 1 Foundation: authentication (email/password + OAuth), session persistence, user data isolation, LLM provider abstraction, and settings UI.

    Steps to verify:
    1. Start services: `docker compose up -d && npm run dev`
    2. Visit http://localhost:3000 — should redirect to /login
    3. Click "Sign up" link, create an account with email/password
    4. After signup, should land on /dashboard with your name displayed
    5. **Session persistence:** Refresh the browser — should still be on /dashboard, still logged in
    6. Navigate to /settings — select a different LLM provider/model — click Save
    7. Refresh /settings — your selection should be preserved
    8. Click "Sign out" — should return to /login
    9. Log back in with email/password — should work
    10. **Data isolation:** Open a different browser (or incognito), create a SECOND account. Go to /settings, set a DIFFERENT provider/model. Verify each account sees only their own settings.
    11. **OAuth (if configured):** If Google/Microsoft OAuth credentials are in .env, test "Sign in with Google" and "Sign in with Microsoft" buttons. They should complete the OAuth flow and land on /dashboard.
    12. **LLM provider registry:** In terminal, run: `cd apps/server && npx tsx -e "import { getAvailableProviders } from './src/llm/providers'; console.log(JSON.stringify(getAvailableProviders(), null, 2))"` — should show 3 providers with models.

    Resume signal: Type "approved" if all checks pass, or describe any issues found.
  </action>
  <verify>Human confirms all 12 verification steps pass</verify>
  <done>All Phase 1 success criteria verified by human: auth works, session persists, data is isolated, LLM providers are selectable</done>
</task>

</tasks>

<verification>
- User can sign up with email/password and land on dashboard
- User can log in with email/password
- User can log in with Google OAuth (when configured)
- User can log in with Microsoft OAuth (when configured)
- Session persists across browser refresh
- Unauthenticated user is redirected to /login
- Settings page shows provider/model selector
- Settings save per-user and persist
- Two different users see different settings (isolation)
- LLM provider registry resolves at least 2 providers
</verification>

<success_criteria>
- All 4 Phase 1 success criteria from ROADMAP.md are met:
  1. User can create an account with email/password and log in with Google or Microsoft OAuth
  2. User session persists across browser refreshes without re-authentication
  3. Each user sees only their own data
  4. System can make LLM calls through at least two different providers and user can select which provider to use
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
