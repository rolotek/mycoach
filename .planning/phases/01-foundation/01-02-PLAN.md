---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - apps/server/src/auth.ts
  - apps/server/src/index.ts
  - apps/server/src/middleware/auth.ts
  - apps/server/src/trpc/router.ts
  - apps/server/src/trpc/context.ts
  - apps/server/src/trpc/procedures/settings.ts
  - apps/server/src/trpc/procedures/llm.ts
  - apps/server/package.json
  - packages/shared/src/types/auth.ts
  - packages/shared/src/types/llm.ts
  - packages/shared/src/schemas/settings.ts
  - packages/shared/src/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Better Auth email/password signup creates a user in the database"
    - "Better Auth email/password login returns a valid session cookie"
    - "Better Auth Google and Microsoft OAuth providers are configured"
    - "Better Auth session cookie persists across requests (cookie cache enabled)"
    - "tRPC protectedProcedure rejects unauthenticated requests with 401"
    - "tRPC protectedProcedure provides ctx.user.id for authenticated requests"
    - "Settings CRUD procedures filter by userId (data isolation)"
  artifacts:
    - path: "apps/server/src/auth.ts"
      provides: "Better Auth instance with email/password + Google + Microsoft OAuth"
      exports: ["auth"]
    - path: "apps/server/src/trpc/router.ts"
      provides: "tRPC app router with public and protected procedures"
      exports: ["appRouter", "AppRouter"]
    - path: "apps/server/src/trpc/context.ts"
      provides: "tRPC context factory injecting user session"
      exports: ["createContext", "Context"]
    - path: "apps/server/src/trpc/procedures/settings.ts"
      provides: "User settings CRUD with userId isolation"
      exports: ["settingsRouter"]
  key_links:
    - from: "apps/server/src/auth.ts"
      to: "apps/server/src/db/index.ts"
      via: "drizzleAdapter(db)"
      pattern: "drizzleAdapter"
    - from: "apps/server/src/index.ts"
      to: "apps/server/src/auth.ts"
      via: "auth.handler mounted on /api/auth/*"
      pattern: "api/auth"
    - from: "apps/server/src/trpc/context.ts"
      to: "apps/server/src/auth.ts"
      via: "auth.api.getSession"
      pattern: "getSession"
    - from: "apps/server/src/trpc/procedures/settings.ts"
      to: "apps/server/src/db/schema.ts"
      via: "db query with userId filter"
      pattern: "eq.*userId.*ctx\\.user\\.id"
---

<objective>
Wire up Better Auth (email/password + Google/Microsoft OAuth) on the Hono server and mount a tRPC router with auth-aware context. Create protectedProcedure that guarantees user identity, and implement user settings CRUD procedures with strict userId isolation. After this plan, the server has a complete auth backend and type-safe API layer.

Purpose: Authentication and type-safe API are the backbone for all user-facing features. Every subsequent plan (LLM, frontend, settings) depends on auth working and tRPC providing typed procedures.
Output: Working auth endpoints on /api/auth/*, tRPC router on /trpc/*, and user settings procedures.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Better Auth server + session middleware + mount on Hono</name>
  <files>
    apps/server/src/auth.ts
    apps/server/src/index.ts
    apps/server/src/middleware/auth.ts
    apps/server/package.json
    packages/shared/src/types/auth.ts
    packages/shared/src/index.ts
  </files>
  <action>
    1. **Install auth dependencies** in apps/server:
       ```bash
       cd apps/server && npm install better-auth @better-auth/cli
       ```

    2. **apps/server/src/auth.ts**: Create Better Auth instance following the research Pattern 1 exactly:
       ```typescript
       import { betterAuth } from "better-auth";
       import { drizzleAdapter } from "better-auth/adapters/drizzle";
       import { db } from "./db";

       export const auth = betterAuth({
         baseURL: process.env.BETTER_AUTH_URL,
         secret: process.env.BETTER_AUTH_SECRET,
         database: drizzleAdapter(db, { provider: "pg" }),
         emailAndPassword: { enabled: true },
         socialProviders: {
           google: {
             clientId: process.env.GOOGLE_CLIENT_ID as string,
             clientSecret: process.env.GOOGLE_CLIENT_SECRET as string,
           },
           microsoft: {
             clientId: process.env.MICROSOFT_CLIENT_ID as string,
             clientSecret: process.env.MICROSOFT_CLIENT_SECRET as string,
             tenantId: "common",
             prompt: "select_account",
           },
         },
         session: {
           cookieCache: { enabled: true, maxAge: 5 * 60 },
           expiresIn: 60 * 60 * 24 * 7,
           updateAge: 60 * 60 * 24,
         },
       });
       ```
       NOTE: Google and Microsoft providers will only activate when their env vars are set. Better Auth handles this gracefully -- if vars are empty strings, those providers are inactive. This is fine for initial dev where only email/password is tested.

    3. **Run Better Auth CLI to generate auth schema**:
       ```bash
       cd apps/server && npx @better-auth/cli generate
       ```
       This generates the SQL or Drizzle schema for Better Auth's internal tables (user, session, account, verification). If it generates a Drizzle schema file, integrate it with our existing schema. If it generates SQL, apply it via drizzle-kit. The key requirement: Better Auth's tables must exist in the database.

       After generation, push the schema: `npx drizzle-kit push`

    4. **apps/server/src/middleware/auth.ts**: Session extraction middleware:
       ```typescript
       import { createMiddleware } from "hono/factory";
       import { auth } from "../auth";

       export const sessionMiddleware = createMiddleware(async (c, next) => {
         const session = await auth.api.getSession({
           headers: c.req.raw.headers,
         });
         c.set("user", session?.user ?? null);
         c.set("session", session?.session ?? null);
         await next();
       });
       ```

    5. **Update apps/server/src/index.ts**: Mount CORS, Better Auth handler, and session middleware:
       ```typescript
       import { Hono } from "hono";
       import { cors } from "hono/cors";
       import { serve } from "@hono/node-server";
       import { auth } from "./auth";
       import { sessionMiddleware } from "./middleware/auth";

       const app = new Hono();

       // CORS -- MUST be before auth routes (see Pitfall 1 in research)
       app.use("/api/auth/*", cors({
         origin: process.env.WEB_URL || "http://localhost:3000",
         allowHeaders: ["Content-Type", "Authorization"],
         allowMethods: ["POST", "GET", "OPTIONS"],
         credentials: true,
       }));

       // Better Auth handler
       app.on(["POST", "GET"], "/api/auth/*", (c) => auth.handler(c.req.raw));

       // Session middleware for all other routes
       app.use("*", sessionMiddleware);

       // Health check
       app.get("/health", (c) => c.json({ status: "ok" }));

       const port = Number(process.env.PORT) || 3001;
       console.log(`Server running on port ${port}`);
       serve({ fetch: app.fetch, port });

       export default app;
       ```
       IMPORTANT: Define Hono type variables for `user` and `session` so TypeScript knows about `c.get("user")`. Use the auth.$Infer pattern from research.

    6. **packages/shared/src/types/auth.ts**: Export shared auth types:
       ```typescript
       export interface AuthUser {
         id: string;
         email: string;
         name: string;
         image?: string | null;
       }
       ```
       Update `packages/shared/src/index.ts` to re-export.
  </action>
  <verify>
    - Server starts without errors: `cd apps/server && npx tsx src/index.ts`
    - Better Auth tables exist in database (check with `psql` or drizzle-kit)
    - POST to `/api/auth/sign-up/email` with `{"email":"test@test.com","password":"testpass123","name":"Test"}` returns 200 with user data
    - POST to `/api/auth/sign-in/email` with `{"email":"test@test.com","password":"testpass123"}` returns 200 with Set-Cookie header containing session
  </verify>
  <done>
    Better Auth is running on Hono with email/password signup and signin working. Google and Microsoft OAuth are configured (but require env vars to be active). Session cookie cache is enabled. Auth middleware injects user/session into Hono context for all routes.
  </done>
</task>

<task type="auto">
  <name>Task 2: tRPC router with auth context + user settings procedures</name>
  <files>
    apps/server/src/trpc/router.ts
    apps/server/src/trpc/context.ts
    apps/server/src/trpc/procedures/settings.ts
    apps/server/src/trpc/procedures/llm.ts
    apps/server/src/index.ts
    apps/server/package.json
    packages/shared/src/schemas/settings.ts
    packages/shared/src/types/llm.ts
    packages/shared/src/index.ts
  </files>
  <action>
    1. **Install tRPC dependencies** in apps/server:
       ```bash
       cd apps/server && npm install @trpc/server @hono/trpc-server
       ```

    2. **apps/server/src/trpc/context.ts**: Create tRPC context factory that extracts auth session from Hono context:
       ```typescript
       import { auth } from "../auth";
       import { db } from "../db";

       export async function createContext(opts: { req: Request }) {
         const session = await auth.api.getSession({
           headers: opts.req.headers,
         });
         return {
           user: session?.user ?? null,
           session: session?.session ?? null,
           db,
         };
       }

       export type Context = Awaited<ReturnType<typeof createContext>>;
       ```
       NOTE: The @hono/trpc-server adapter passes the Hono context. Check the actual adapter API -- it may pass `(opts, c)` where `c` is the Hono context. Adapt the createContext signature accordingly to extract `c.req.raw.headers`.

    3. **apps/server/src/trpc/router.ts**: Initialize tRPC and create router with publicProcedure and protectedProcedure:
       ```typescript
       import { initTRPC, TRPCError } from "@trpc/server";
       import type { Context } from "./context";
       import { settingsRouter } from "./procedures/settings";

       const t = initTRPC.context<Context>().create();

       export const publicProcedure = t.procedure;
       export const protectedProcedure = t.procedure.use(({ ctx, next }) => {
         if (!ctx.user) {
           throw new TRPCError({ code: "UNAUTHORIZED" });
         }
         return next({
           ctx: { ...ctx, user: ctx.user, session: ctx.session! },
         });
       });

       export const appRouter = t.router({
         settings: settingsRouter,
       });

       export type AppRouter = typeof appRouter;
       ```

    4. **packages/shared/src/schemas/settings.ts**: Zod schemas for settings:
       ```typescript
       import { z } from "zod";
       export const updateSettingsSchema = z.object({
         preferredProvider: z.string().optional(),
         preferredModel: z.string().optional(),
       });
       ```

    5. **packages/shared/src/types/llm.ts**: LLM-related types:
       ```typescript
       export interface LLMProvider {
         id: string;
         name: string;
         models: LLMModel[];
       }
       export interface LLMModel {
         id: string;
         name: string;
         providerId: string;
       }
       ```

    6. **apps/server/src/trpc/procedures/settings.ts**: User settings CRUD with userId isolation:
       ```typescript
       import { z } from "zod";
       import { protectedProcedure } from "../router";
       import { db } from "../../db";
       import { userSettings } from "../../db/schema";
       import { eq } from "drizzle-orm";

       // Use a sub-router via t.router from the parent
       export const settingsRouter = t.router({
         get: protectedProcedure.query(async ({ ctx }) => {
           const result = await ctx.db
             .select()
             .from(userSettings)
             .where(eq(userSettings.userId, ctx.user.id));
           return result[0] ?? null;
         }),
         update: protectedProcedure
           .input(updateSettingsSchema)
           .mutation(async ({ ctx, input }) => {
             // Upsert pattern: try update, if no rows affected, insert
             const existing = await ctx.db
               .select()
               .from(userSettings)
               .where(eq(userSettings.userId, ctx.user.id));
             if (existing.length > 0) {
               await ctx.db
                 .update(userSettings)
                 .set({ ...input, updatedAt: new Date() })
                 .where(eq(userSettings.userId, ctx.user.id));
             } else {
               await ctx.db.insert(userSettings).values({
                 userId: ctx.user.id,
                 ...input,
               });
             }
             return { success: true };
           }),
       });
       ```
       CRITICAL: Every query MUST include `.where(eq(userSettings.userId, ctx.user.id))`. No exceptions. This is the data isolation mechanism (AUTH-05).

    7. **apps/server/src/trpc/procedures/llm.ts**: LLM provider listing procedure (a static list for now -- the actual registry is Plan 03):
       ```typescript
       export const llmRouter = t.router({
         listProviders: publicProcedure.query(() => {
           return [
             { id: "anthropic", name: "Anthropic (Claude)", models: [
               { id: "anthropic:claude-sonnet-4-20250514", name: "Claude Sonnet 4", providerId: "anthropic" },
             ]},
             { id: "openai", name: "OpenAI", models: [
               { id: "openai:gpt-4o", name: "GPT-4o", providerId: "openai" },
             ]},
             { id: "ollama", name: "Ollama (Local)", models: [
               { id: "ollama:llama3.1", name: "Llama 3.1", providerId: "ollama" },
             ]},
           ];
         }),
       });
       ```
       Add `llm: llmRouter` to the appRouter.

    8. **Mount tRPC on Hono** in apps/server/src/index.ts:
       ```typescript
       import { trpcServer } from "@hono/trpc-server";
       import { appRouter } from "./trpc/router";
       import { createContext } from "./trpc/context";

       // Add after session middleware, before health check:
       app.use("/trpc/*", trpcServer({
         router: appRouter,
         createContext: (opts, c) => createContext({ req: c.req.raw }),
       }));
       ```
       Also add CORS for `/trpc/*` routes matching the same origin config as auth.

    9. Update **packages/shared/src/index.ts** to re-export all new types and schemas.
  </action>
  <verify>
    - Server starts without TypeScript errors
    - `curl http://localhost:3001/trpc/llm.listProviders` returns the provider list JSON
    - Sign up a test user, capture the session cookie, then:
      - `curl -b "cookie" http://localhost:3001/trpc/settings.get` returns null (no settings yet)
      - `curl -X POST -b "cookie" -H "Content-Type: application/json" -d '{"json":{"preferredModel":"openai:gpt-4o"}}' http://localhost:3001/trpc/settings.update` returns success
      - `curl -b "cookie" http://localhost:3001/trpc/settings.get` returns the updated settings
    - `curl http://localhost:3001/trpc/settings.get` (no cookie) returns UNAUTHORIZED error
  </verify>
  <done>
    tRPC is mounted on Hono at /trpc/*. protectedProcedure rejects unauthenticated requests. Settings procedures perform CRUD with strict userId filtering. LLM provider listing returns available providers. The API layer is ready for frontend consumption.
  </done>
</task>

</tasks>

<verification>
- Server starts cleanly with auth + tRPC mounted
- Better Auth signup/signin works via curl
- Session cookie is returned and accepted on subsequent requests
- tRPC settings procedures enforce userId isolation
- tRPC rejects unauthenticated requests to protected procedures
- LLM provider list is accessible
</verification>

<success_criteria>
- POST /api/auth/sign-up/email creates a user and returns session
- POST /api/auth/sign-in/email authenticates and returns session cookie
- Session cookie cache is enabled (5-min maxAge)
- Google and Microsoft OAuth are configured (active when env vars present)
- tRPC protectedProcedure returns 401 without valid session
- settings.get and settings.update filter by ctx.user.id
- All tRPC procedures are type-safe end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
