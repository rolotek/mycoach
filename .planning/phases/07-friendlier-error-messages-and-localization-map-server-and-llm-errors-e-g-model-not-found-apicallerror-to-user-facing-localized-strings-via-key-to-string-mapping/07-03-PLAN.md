---
phase: 07-friendlier-errors-and-i18n
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - apps/server/src/coaching/chat-route.ts
  - apps/server/src/llm/providers.ts
  - apps/web/messages/en.json
  - apps/web/src/app/[locale]/(app)/chat/[id]/page.tsx
  - apps/web/src/hooks/use-coaching-chat.ts
  - apps/web/src/app/[locale]/(auth)/login/page.tsx
  - apps/web/src/app/[locale]/(auth)/signup/page.tsx
autonomous: true

must_haves:
  truths:
    - "Server returns a stable error key (e.g. errors.modelNotFound) when a known error type is detected, so client can show localized message"
    - "Known errors mapped: model not found / invalid model, API key missing/invalid, rate limit, generic LLM/API failure"
    - "Client checks for error key (e.g. JSON with { errorKey: 'errors.modelNotFound' }) and uses t(errorKey); otherwise falls back to message or errors.generic"
    - "messages/en.json errors namespace has keys for all mapped error types"
  artifacts:
    - path: "apps/server/src/coaching/chat-route.ts"
      provides: "extractUserFacingError returns key or message; known errors return key"
    - path: "apps/web/messages/en.json"
      provides: "errors.* keys with friendly English messages"
---

<objective>
Map server and LLM errors to stable error keys and show localized messages in the UI. Server detects known error patterns (model not found, API key invalid, rate limit, etc.), returns an error key; client resolves key to message via useTranslations('errors'). Unknown errors still get a generic localized message or the raw message as fallback.

Purpose: Users see friendly, consistent, localizable messages instead of raw API/stack text.
Output: Chat route (and any other error-emitting server code) returns { errorKey } or { message } as agreed contract; client displays t(errorKey) when errorKey present; en.json errors namespace populated.
</objective>

<execution_context>
@./.cursor/get-shit-done/workflows/execute-plan.md
@./.cursor/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-friendlier-error-messages-and-localization-map-server-and-llm-errors-e-g-model-not-found-apicallerror-to-user-facing-localized-strings-via-key-to-string-mapping/07-01-SUMMARY.md
@.planning/phases/07-friendlier-error-messages-and-localization-map-server-and-llm-errors-e-g-model-not-found-apicallerror-to-user-facing-localized-strings-via-key-to-string-mapping/07-02-SUMMARY.md
@apps/server/src/coaching/chat-route.ts
@apps/server/src/llm/providers.ts
@apps/web/src/app/[locale]/(app)/chat/[id]/page.tsx
@apps/web/src/hooks/use-coaching-chat.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define error key contract and server-side mapping</name>
  <files>apps/server/src/coaching/chat-route.ts, apps/server/src/llm/providers.ts</files>
  <action>
1. Define a small set of error keys and when to use them:
   - errors.modelNotFound — model id invalid or not found (e.g. provider returns 404 or "model ... not found")
   - errors.apiKeyMissing — no API key configured (user or env)
   - errors.apiKeyInvalid — key rejected by provider
   - errors.rateLimit — rate limit or quota exceeded
   - errors.generic — fallback when no specific key matches

2. In chat-route.ts: Refactor extractUserFacingErrorMessage (or add a parallel function) to return either:
   - An object { errorKey: string } for known patterns (e.g. detect "not found", "invalid api key", "rate limit" in message or error type)
   - Or keep returning a string for backward compatibility; then in the same place where the error is sent to the client (e.g. in the stream or response), send a JSON payload that includes errorKey when applicable. Contract: client receives either { errorKey: "errors.xxx" } or { message: "raw or fallback" }.

3. In providers.ts (or wherever ApiKeyRequiredError / validation errors are thrown): ensure thrown errors can be classified (e.g. ApiKeyRequiredError -> errors.apiKeyMissing; invalid key response -> errors.apiKeyInvalid). Chat route should catch these and convert to errorKey in the response to the client.

4. Document the contract: when the client gets an error from the chat API, it may receive a body with errorKey (translation key) and/or message. Prefer errorKey for display when present.
</action>
  <verify>
Known error scenarios (e.g. wrong model id, missing key) result in errorKey in response; client can read errorKey.
</verify>
</task>

<task type="auto">
  <name>Task 2: Populate errors namespace in en.json and wire client</name>
  <files>apps/web/messages/en.json, apps/web/src/app/[locale]/(app)/chat/[id]/page.tsx, apps/web/src/hooks/use-coaching-chat.ts</files>
  <action>
1. In apps/web/messages/en.json, under errors (or a dedicated "errors" namespace), add keys and English strings:
   - modelNotFound: "The selected model wasn't found. Check Settings or try another model."
   - apiKeyMissing: "No API key is set. Add one in Settings."
   - apiKeyInvalid: "Your API key is invalid or was rejected. Check Settings."
   - rateLimit: "Rate limit reached. Please try again later."
   - generic: "Something went wrong. Please try again or check Settings."

2. In the chat [id] page (where chatError is displayed): when parsing the error payload, if errorKey is present, call t(errorKey) (useTranslations or pass locale and get translation for that key). If only message is present, show message. Optionally show a Dismiss button using common.dismiss.

3. In use-coaching-chat or wherever the error is set: ensure the error object passed to the UI includes errorKey when the server sent it (so the page can read errorKey and call t(errorKey)).
</action>
  <verify>
Triggering a known error (e.g. invalid model) shows the friendly English message from en.json; client uses errorKey when present.
</verify>
</task>

<task type="auto">
  <name>Task 3: Auth and other server errors</name>
  <files>apps/web/src/app/[locale]/(auth)/login/page.tsx, apps/web/src/app/[locale]/(auth)/signup/page.tsx, apps/web/messages/en.json</files>
  <action>
For login/signup: if auth already returns a message string, keep using it but optionally map known auth error codes to error keys (e.g. auth.invalidCredentials) and add those to en.json. If no code/category is returned, leave as-is; only add keys where it improves UX. Ensure any "Login failed" / "Sign up failed" type fallbacks use translation keys (from 07-02).
</action>
  <verify>
Auth pages show localized messages; no regression in error display.
</verify>
</task>

</tasks>

After completion, create `.planning/phases/07-friendlier-error-messages-and-localization-map-server-and-llm-errors-e-g-model-not-found-apicallerror-to-user-facing-localized-strings-via-key-to-string-mapping/07-03-SUMMARY.md`
