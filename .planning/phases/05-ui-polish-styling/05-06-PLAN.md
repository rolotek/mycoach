---
phase: 05-ui-polish-styling
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/server/src/db/schema.ts
  - apps/server/src/trpc/router.ts
  - apps/server/src/agents/agent-executor.ts
  - apps/server/src/coaching/chat-route.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Conversations table has a 'type' column distinguishing coaching vs task threads"
    - "Conversations table has a 'parentId' column linking task threads to the coaching thread"
    - "Each user has exactly one coaching thread (auto-created if missing)"
    - "Agent dispatch creates a new task thread linked to the coaching thread"
    - "Reset mutation clears coaching thread messages but does NOT delete userFacts or memories"
    - "Task threads store the full agent result as conversation messages"
  artifacts:
    - path: "apps/server/src/db/schema.ts"
      provides: "type and parentId columns on conversations table"
      contains: "type.*coaching.*task"
    - path: "apps/server/src/trpc/router.ts"
      provides: "getOrCreateCoaching, reset, listTaskThreads mutations/queries"
      exports: "conversationRouter"
    - path: "apps/server/src/agents/agent-executor.ts"
      provides: "Task thread creation on agent execution"
      contains: "conversations"
    - path: "apps/server/src/coaching/chat-route.ts"
      provides: "Chat route uses coaching thread, links task threads"
      contains: "coaching"
  key_links:
    - from: "apps/server/src/agents/agent-executor.ts"
      to: "apps/server/src/db/schema.ts"
      via: "insert into conversations with type=task and parentId"
      pattern: "type.*task"
    - from: "apps/server/src/coaching/chat-route.ts"
      to: "apps/server/src/trpc/router.ts"
      via: "coaching thread lookup/creation"
      pattern: "coaching"
---

<objective>
Add conversation model backend: type/parentId columns on conversations, getOrCreateCoaching query, reset mutation, task thread creation on agent dispatch.

Purpose: Transform the flat conversation list into a hybrid coaching + task thread model per locked decision. The coaching thread is the persistent coaching relationship; task threads are created per agent dispatch.

Output: Updated schema, tRPC procedures, agent executor, and chat route.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-ui-polish-styling/05-CONTEXT.md

@apps/server/src/db/schema.ts
@apps/server/src/trpc/router.ts
@apps/server/src/agents/agent-executor.ts
@apps/server/src/coaching/chat-route.ts
@apps/server/src/agents/resolve-approved-dispatch.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add type/parentId columns to conversations + new tRPC procedures</name>
  <files>
    apps/server/src/db/schema.ts
    apps/server/src/trpc/router.ts
  </files>
  <action>
**schema.ts changes:**

1. Add two new columns to the `conversations` table:
   - `type`: `text("type").default("general").notNull()` -- values: "coaching", "task", "general" (general = legacy conversations before this migration)
   - `parentId`: `uuid("parent_id").references(() => conversations.id, { onDelete: "cascade" })` -- null for coaching/general threads, points to coaching thread for task threads

2. Add an index on `parentId` for efficient task thread lookups:
   - `index("conversations_parentId_idx").on(table.parentId)`

3. Update `conversationRelations` to include self-referential relations:
   - `parent: one(conversations, { fields: [conversations.parentId], references: [conversations.id], relationName: "taskThreads" })`
   - Add `taskThreads: many(conversations, { relationName: "taskThreads" })` to a new conversations relation

**router.ts conversationRouter changes:**

1. Add `getOrCreateCoaching` procedure (protectedProcedure, query):
   - SELECT from conversations WHERE userId = ctx.user.id AND type = "coaching" LIMIT 1
   - If found, return it
   - If not found, INSERT a new conversation with type="coaching", title="Coaching", return it
   - This is idempotent -- always returns exactly one coaching thread per user

2. Add `reset` procedure (protectedProcedure, mutation):
   - Input: `{ id: z.string().uuid() }`
   - Verify the conversation exists, belongs to user, AND type = "coaching" (reject reset on non-coaching threads with FORBIDDEN error)
   - UPDATE conversations SET messages = '[]', updatedAt = NOW() WHERE id = input.id AND userId = ctx.user.id
   - Do NOT delete memories or userFacts -- per locked decision, reset clears messages but memory persists
   - Return `{ success: true }`

3. Add `listTaskThreads` procedure (protectedProcedure, query):
   - Input: `{ parentId: z.string().uuid().optional() }`
   - If parentId provided: SELECT id, title, createdAt, updatedAt FROM conversations WHERE userId = ctx.user.id AND type = "task" AND parentId = input.parentId ORDER BY updatedAt DESC
   - If not provided: SELECT id, title, createdAt, updatedAt FROM conversations WHERE userId = ctx.user.id AND type = "task" ORDER BY updatedAt DESC
   - Return the list

4. Modify the existing `list` procedure: add a `type` filter parameter (optional). If `type` is provided, filter by it. Otherwise return all (backward compatible).

5. Modify the existing `delete` procedure: when deleting a coaching thread, also delete all task threads with parentId = that id (the cascade on parentId should handle this, but verify).
  </action>
  <verify>
    cd /Users/allenwong/Workspace/mycoach && npx tsc --noEmit -p apps/server/tsconfig.json
    Run `npm run db:push` from apps/server to apply schema changes.
  </verify>
  <done>
    - conversations table has type and parentId columns
    - getOrCreateCoaching returns a single coaching thread per user
    - reset clears messages on coaching thread only
    - listTaskThreads returns task threads ordered by recency
    - db:push succeeds with no errors
    - tsc passes with no type errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire agent executor to create task threads + update chat route for coaching model</name>
  <files>
    apps/server/src/agents/agent-executor.ts
    apps/server/src/coaching/chat-route.ts
  </files>
  <action>
**agent-executor.ts changes:**

1. After creating the agentExecution row and after the agent completes successfully, create a task thread:
   - INSERT into conversations: `{ userId, type: "task", parentId: conversationId, title: "${agent.name} - ${new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}", messages: [] }`
   - The `conversationId` parameter passed in is the coaching thread ID (the parent)
   - Store the agent result as a single assistant message in the task thread's messages array (jsonb):
     ```
     [{ id: crypto.randomUUID(), role: "assistant", content: result.text, parts: [{ type: "text", text: result.text }] }]
     ```
   - Update the agentExecution row to set `conversationId` to the NEW task thread ID (not the parent coaching thread) so the execution is linked to the task thread
   - Return the new `taskThreadId` in the response alongside agentName, result, executionId, agentId

2. Update the return type to include `taskThreadId: string`.

**resolve-approved-dispatch.ts changes:**

1. Update the `ExecutedDispatchResult.output` type to include `taskThreadId?: string`
2. Pass through the taskThreadId from executeSpecialistAgent

**chat-route.ts changes:**

1. Instead of creating a new conversation when chatId is missing, use `getOrCreateCoaching` logic inline:
   - Look for existing coaching thread: SELECT from conversations WHERE userId = user.id AND type = "coaching"
   - If not found, INSERT with type = "coaching", title = "Coaching"
   - Set chatId to this coaching thread's ID
   - This means navigating to /chat always lands on the coaching thread

2. When the body includes a `chatId` that maps to a task thread (type = "task"), load messages and respond in that thread's context (allow viewing/continuing task threads). However, the primary flow is: user always chats in coaching thread, agent dispatches create task threads automatically.

3. Ensure the `X-Chat-Id` header always returns the coaching thread ID when chatting in the coaching thread.

4. The onFinish callback should continue saving messages to the correct conversation (chatId).
  </action>
  <verify>
    cd /Users/allenwong/Workspace/mycoach && npx tsc --noEmit -p apps/server/tsconfig.json
  </verify>
  <done>
    - Agent dispatch creates a new task thread with type="task" and parentId=coachingThreadId
    - Task thread title follows "Agent Name - Mon DD" format
    - Agent result is stored as messages in the task thread
    - Chat route auto-creates/finds coaching thread when no chatId provided
    - tsc passes with no type errors
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p apps/server/tsconfig.json` passes
2. `npm run db:push` from apps/server succeeds
3. Schema has type and parentId columns on conversations
4. conversationRouter has getOrCreateCoaching, reset, listTaskThreads procedures
5. agent-executor creates task threads on successful dispatch
</verification>

<success_criteria>
- Conversations table distinguishes coaching vs task threads via type column
- Task threads link to coaching thread via parentId
- getOrCreateCoaching is idempotent (one coaching thread per user)
- Reset clears coaching messages but preserves userFacts/memories
- Agent dispatch creates task thread with full result stored as messages
- All TypeScript compilation passes
- db:push applies cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/05-ui-polish-styling/05-06-SUMMARY.md`
</output>
