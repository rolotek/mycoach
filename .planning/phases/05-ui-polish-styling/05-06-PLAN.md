---
phase: 05-ui-polish-styling
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/server/src/db/schema.ts
  - apps/server/src/trpc/router.ts
  - apps/server/src/agents/resolve-approved-dispatch.ts
  - apps/server/src/agents/agent-executor.ts
  - apps/server/src/coaching/chat-route.ts
autonomous: true

must_haves:
  truths:
    - "Conversations have a type field distinguishing coaching threads from task threads"
    - "Task threads are linked to their parent coaching conversation via parentId"
    - "When an agent dispatch is approved, a new task conversation is created with the agent result"
    - "Reset action clears coaching conversation messages but the conversation row persists"
    - "Conversation list endpoint returns type and parentId so the frontend can group them"
  artifacts:
    - path: "apps/server/src/db/schema.ts"
      provides: "conversations table with type and parentId columns"
      contains: "type.*text.*default.*coaching"
    - path: "apps/server/src/trpc/router.ts"
      provides: "reset mutation, list returns type/parentId"
      contains: "reset.*protectedProcedure"
    - path: "apps/server/src/agents/resolve-approved-dispatch.ts"
      provides: "Task thread creation on approved dispatch"
      contains: "insert.*conversations.*type.*task"
  key_links:
    - from: "apps/server/src/agents/resolve-approved-dispatch.ts"
      to: "apps/server/src/db/schema.ts"
      via: "conversations insert with type='task' and parentId"
      pattern: "type.*task"
    - from: "apps/server/src/trpc/router.ts"
      to: "apps/server/src/db/schema.ts"
      via: "reset mutation deletes messages from coaching conversation"
      pattern: "reset"
---

<objective>
Add conversation model backend support: type field ("coaching" | "task"), parentId for task threads, task thread creation on agent dispatch, and coaching reset.

Purpose: The locked decision requires a hybrid coaching + task thread model. This plan adds the DB schema changes and server-side logic so the frontend can present pinned coaching threads and separate task threads.

Output: Updated schema with type/parentId, tRPC procedures for reset and typed listing, agent executor creates task threads on dispatch approval.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/server/src/db/schema.ts
@apps/server/src/trpc/router.ts
@apps/server/src/agents/resolve-approved-dispatch.ts
@apps/server/src/agents/agent-executor.ts
@apps/server/src/coaching/chat-route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add type and parentId to conversations schema + push migration</name>
  <files>apps/server/src/db/schema.ts</files>
  <action>
In the `conversations` table definition in `apps/server/src/db/schema.ts`:

1. Add a `type` column: `type: text("type").default("coaching").notNull()` -- values are "coaching" or "task". Default to "coaching" so all existing conversations automatically become coaching threads.

2. Add a `parentId` column: `parentId: uuid("parent_id").references(() => conversations.id, { onDelete: "cascade" })` -- nullable, only set on task threads to point back to the coaching conversation that spawned them.

3. Add an index on `parentId`: `index("conversations_parentId_idx").on(table.parentId)` in the table's indexes array.

4. Update `conversationRelations` to add a self-referential relation:
```typescript
export const conversationRelations = relations(conversations, ({ one, many }) => ({
  user: one(user, {
    fields: [conversations.userId],
    references: [user.id],
  }),
  parent: one(conversations, {
    fields: [conversations.parentId],
    references: [conversations.id],
    relationName: "taskThreads",
  }),
  taskThreads: many(conversations, { relationName: "taskThreads" }),
}));
```

5. Run `npx drizzle-kit push` from apps/server to apply the schema change to the database. Use `--force` flag if it prompts for confirmation (since we are adding columns with defaults, this is safe for existing data).
  </action>
  <verify>
Run `npx drizzle-kit push` from apps/server -- should succeed with no errors.
Run `npx tsc --noEmit` from apps/server -- should compile without type errors.
  </verify>
  <done>
conversations table has `type` (defaulting "coaching") and `parentId` (nullable UUID FK) columns. All existing conversations are type "coaching". Schema compiles and is pushed to DB.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update tRPC conversation procedures + agent dispatch to create task threads</name>
  <files>apps/server/src/trpc/router.ts, apps/server/src/agents/resolve-approved-dispatch.ts, apps/server/src/coaching/chat-route.ts</files>
  <action>
**In `apps/server/src/trpc/router.ts` (conversationRouter):**

1. Update `conversation.list` to also select `type` and `parentId` fields:
```typescript
list: protectedProcedure.query(async ({ ctx }) => {
  return ctx.db
    .select({
      id: conversations.id,
      title: conversations.title,
      mode: conversations.mode,
      type: conversations.type,
      parentId: conversations.parentId,
      createdAt: conversations.createdAt,
      updatedAt: conversations.updatedAt,
    })
    .from(conversations)
    .where(eq(conversations.userId, ctx.user.id))
    .orderBy(desc(conversations.updatedAt));
}),
```

2. Update `conversation.create` to accept an optional `type` and `parentId`:
```typescript
create: protectedProcedure
  .input(
    z.object({
      mode: z.enum(["auto", "coaching", "task"]).default("auto"),
      type: z.enum(["coaching", "task"]).default("coaching"),
      parentId: z.string().uuid().optional(),
    })
  )
  .mutation(async ({ ctx, input }) => {
    const [row] = await ctx.db
      .insert(conversations)
      .values({
        userId: ctx.user.id,
        mode: input.mode,
        type: input.type,
        parentId: input.parentId ?? null,
      })
      .returning({ id: conversations.id, mode: conversations.mode, type: conversations.type });
    return row!;
  }),
```

3. Add a `conversation.reset` mutation that clears messages but keeps the conversation row:
```typescript
reset: protectedProcedure
  .input(z.object({ id: z.string().uuid() }))
  .mutation(async ({ ctx, input }) => {
    const [row] = await ctx.db
      .select({ type: conversations.type })
      .from(conversations)
      .where(
        and(
          eq(conversations.id, input.id),
          eq(conversations.userId, ctx.user.id)
        )
      );
    if (!row) throw new TRPCError({ code: "NOT_FOUND" });
    if (row.type !== "coaching") {
      throw new TRPCError({
        code: "BAD_REQUEST",
        message: "Only coaching conversations can be reset",
      });
    }
    await ctx.db
      .update(conversations)
      .set({ messages: [], updatedAt: new Date() })
      .where(
        and(
          eq(conversations.id, input.id),
          eq(conversations.userId, ctx.user.id)
        )
      );
    return { success: true };
  }),
```

4. Add a `conversation.getOrCreateCoaching` query that returns the user's coaching conversation, creating one if none exists:
```typescript
getOrCreateCoaching: protectedProcedure.mutation(async ({ ctx }) => {
  const [existing] = await ctx.db
    .select({ id: conversations.id })
    .from(conversations)
    .where(
      and(
        eq(conversations.userId, ctx.user.id),
        eq(conversations.type, "coaching")
      )
    )
    .limit(1);
  if (existing) return existing;
  const [row] = await ctx.db
    .insert(conversations)
    .values({
      userId: ctx.user.id,
      type: "coaching",
      mode: "auto",
      title: "Coaching",
    })
    .returning({ id: conversations.id });
  return row!;
}),
```

**In `apps/server/src/agents/resolve-approved-dispatch.ts`:**

Update `resolveApprovedDispatchTools` to create a task thread conversation when a dispatch is approved. The function signature needs to accept `db` import (it already imports from `../db`). After a successful agent execution:

1. Import `conversations` from the schema at the top.
2. After `executeSpecialistAgent` returns successfully, create a new task conversation:
```typescript
import { db } from "../db";
import { conversations } from "../db/schema";

// Inside the try block, after executeSpecialistAgent returns:
const [taskConv] = await db
  .insert(conversations)
  .values({
    userId,
    type: "task",
    parentId: conversationId ?? null,
    mode: "task",
    title: `${agentName} - ${new Date().toLocaleDateString("en-US", { month: "short", day: "numeric" })}`,
    messages: [
      {
        id: crypto.randomUUID(),
        role: "assistant",
        content: result,
        parts: [{ type: "text", text: result }],
      },
    ],
  })
  .returning({ id: conversations.id });
```

3. Add `taskConversationId: taskConv?.id` to the output object and update the `ExecutedDispatchResult` type to include it:
```typescript
export type ExecutedDispatchResult = {
  toolCallId: string;
  output: {
    agentName: string;
    result: string;
    executionId: string;
    agentId: string;
    taskConversationId?: string;
  };
};
```

**In `apps/server/src/coaching/chat-route.ts`:**

In the `chatApp.post("/api/chat")` handler, when creating a new conversation (the `if (!chatId)` block), set `type: "coaching"` explicitly:
```typescript
if (!chatId) {
  const [conv] = await db
    .insert(conversations)
    .values({ userId: user.id, mode: modeOverride, type: "coaching" })
    .returning();
  chatId = conv.id;
}
```

This ensures any conversation created via the chat endpoint is a coaching conversation.
  </action>
  <verify>
Run `npx tsc --noEmit` from apps/server -- no type errors.
Run `npx tsc --noEmit` from apps/web -- no type errors (tRPC types auto-infer).
  </verify>
  <done>
- conversation.list returns type and parentId
- conversation.create accepts type and parentId
- conversation.reset clears messages on coaching conversations only
- conversation.getOrCreateCoaching finds or creates the single coaching thread
- Agent dispatch approval creates a task conversation with the result
- Chat route creates coaching-typed conversations
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in both apps/server and apps/web
2. Schema has type and parentId columns on conversations
3. New tRPC procedures (reset, getOrCreateCoaching) are defined and type-safe
4. resolve-approved-dispatch creates task conversations with agent results
</verification>

<success_criteria>
- conversations table has `type` (default "coaching") and `parentId` (nullable FK to conversations.id) columns
- All existing conversations default to type "coaching"
- tRPC router exposes reset, getOrCreateCoaching, and typed create/list procedures
- Agent dispatch approval creates a separate task conversation linked to parent coaching conversation
- TypeScript compiles without errors in both server and web packages
</success_criteria>

<output>
After completion, create `.planning/phases/05-ui-polish-styling/05-06-SUMMARY.md`
</output>
