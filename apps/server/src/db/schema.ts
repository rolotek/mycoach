import { relations } from "drizzle-orm";
import type { AnyPgColumn } from "drizzle-orm/pg-core";
import {
  pgTable,
  text,
  timestamp,
  uuid,
  varchar,
  jsonb,
  boolean,
  index,
  integer,
  real,
  vector,
  unique,
} from "drizzle-orm/pg-core";

// Better Auth tables (generated by @better-auth/cli, merged here)
export const user = pgTable("user", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  emailVerified: boolean("email_verified").default(false).notNull(),
  image: text("image"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
});

export const session = pgTable(
  "session",
  {
    id: text("id").primaryKey(),
    expiresAt: timestamp("expires_at").notNull(),
    token: text("token").notNull().unique(),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at")
      .$onUpdate(() => new Date())
      .notNull(),
    ipAddress: text("ip_address"),
    userAgent: text("user_agent"),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
  },
  (table) => [index("session_userId_idx").on(table.userId)]
);

export const account = pgTable(
  "account",
  {
    id: text("id").primaryKey(),
    accountId: text("account_id").notNull(),
    providerId: text("provider_id").notNull(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    accessToken: text("access_token"),
    refreshToken: text("refresh_token"),
    idToken: text("id_token"),
    accessTokenExpiresAt: timestamp("access_token_expires_at"),
    refreshTokenExpiresAt: timestamp("refresh_token_expires_at"),
    scope: text("scope"),
    password: text("password"),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at")
      .$onUpdate(() => new Date())
      .notNull(),
  },
  (table) => [index("account_userId_idx").on(table.userId)]
);

export const verification = pgTable(
  "verification",
  {
    id: text("id").primaryKey(),
    identifier: text("identifier").notNull(),
    value: text("value").notNull(),
    expiresAt: timestamp("expires_at").notNull(),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at")
      .defaultNow()
      .$onUpdate(() => new Date())
      .notNull(),
  },
  (table) => [index("verification_identifier_idx").on(table.identifier)]
);

export const userRelations = relations(user, ({ many }) => ({
  sessions: many(session),
  accounts: many(account),
  conversations: many(conversations),
  documents: many(documents),
  userFacts: many(userFacts),
  agents: many(agents),
  apiKeys: many(userApiKeys),
  tokenUsage: many(tokenUsage),
  projects: many(projects),
}));

export const sessionRelations = relations(session, ({ one }) => ({
  user: one(user, {
    fields: [session.userId],
    references: [user.id],
  }),
}));

export const accountRelations = relations(account, ({ one }) => ({
  user: one(user, {
    fields: [account.userId],
    references: [user.id],
  }),
}));

// Application tables
export const userSettings = pgTable("user_settings", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: text("user_id").notNull(),
  preferredProvider: varchar("preferred_provider", { length: 50 }).default(
    "anthropic"
  ),
  preferredModel: varchar("preferred_model", { length: 100 }).default(
    "anthropic:claude-sonnet-4-20250514"
  ),
  settings: jsonb("settings").default({}),
  monthlyBudgetCents: integer("monthly_budget_cents"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Phase 2: Coaching & Memory
export const conversations = pgTable(
  "conversations",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    title: text("title"),
    mode: text("mode").default("auto").notNull(),
    type: text("type").default("coaching").notNull(),
    parentId: uuid("parent_id").references((): AnyPgColumn => conversations.id, {
      onDelete: "cascade",
    }),
    projectId: uuid("project_id").references((): AnyPgColumn => projects.id, {
      onDelete: "set null",
    }),
    milestoneId: uuid("milestone_id").references((): AnyPgColumn => projectMilestones.id, {
      onDelete: "set null",
    }),
    messages: jsonb("messages").default([]),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => [
    index("conversations_userId_idx").on(table.userId),
    index("conversations_parentId_idx").on(table.parentId),
    index("conversations_projectId_idx").on(table.projectId),
    index("conversations_milestoneId_idx").on(table.milestoneId),
  ]
);

export const memories = pgTable(
  "memories",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    conversationId: uuid("conversation_id").references(
      () => conversations.id,
      { onDelete: "set null" }
    ),
    content: text("content").notNull(),
    embedding: vector("embedding", { dimensions: 1536 }),
    type: text("type").notNull(),
    metadata: jsonb("metadata").default({}),
    createdAt: timestamp("created_at").defaultNow().notNull(),
  },
  (table) => [
    index("memories_userId_idx").on(table.userId),
    index("memories_embedding_idx").using(
      "hnsw",
      table.embedding.op("vector_cosine_ops")
    ),
  ]
);

export const documents = pgTable(
  "documents",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    filename: text("filename").notNull(),
    mimeType: text("mime_type").notNull(),
    content: text("content"),
    size: integer("size").notNull(),
    status: text("status").default("processing").notNull(),
    createdAt: timestamp("created_at").defaultNow().notNull(),
  },
  (table) => [index("documents_userId_idx").on(table.userId)]
);

// Phase 8: Projects
export const projects = pgTable(
  "projects",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    name: text("name").notNull(),
    description: text("description"),
    status: varchar("status", { length: 50 }).default("active").notNull(),
    dueDate: timestamp("due_date"),
    pinnedAt: timestamp("pinned_at"),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at")
      .defaultNow()
      .$onUpdate(() => new Date())
      .notNull(),
  },
  (table) => [index("projects_userId_idx").on(table.userId)]
);

export const projectDocuments = pgTable(
  "project_documents",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    projectId: uuid("project_id")
      .notNull()
      .references(() => projects.id, { onDelete: "cascade" }),
    documentId: uuid("document_id")
      .notNull()
      .references(() => documents.id, { onDelete: "cascade" }),
    milestoneId: uuid("milestone_id").references((): AnyPgColumn => projectMilestones.id, {
      onDelete: "set null",
    }),
    createdAt: timestamp("created_at").defaultNow().notNull(),
  },
  (table) => [
    index("project_documents_projectId_idx").on(table.projectId),
    unique("project_documents_projectId_documentId_unique").on(
      table.projectId,
      table.documentId
    ),
  ]
);

export const projectLinks = pgTable(
  "project_links",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    projectId: uuid("project_id")
      .notNull()
      .references(() => projects.id, { onDelete: "cascade" }),
    url: text("url").notNull(),
    label: text("label").notNull(),
    linkType: varchar("link_type", { length: 50 }).default("generic").notNull(),
    milestoneId: uuid("milestone_id").references((): AnyPgColumn => projectMilestones.id, {
      onDelete: "set null",
    }),
    createdAt: timestamp("created_at").defaultNow().notNull(),
  },
  (table) => [index("project_links_projectId_idx").on(table.projectId)]
);

export const projectMilestones = pgTable(
  "project_milestones",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    projectId: uuid("project_id")
      .notNull()
      .references(() => projects.id, { onDelete: "cascade" }),
    title: text("title").notNull(),
    dueDate: timestamp("due_date"),
    sortOrder: integer("sort_order").notNull().default(0),
    status: varchar("status", { length: 50 }),
    createdAt: timestamp("created_at").defaultNow().notNull(),
  },
  (table) => [index("project_milestones_projectId_idx").on(table.projectId)]
);

export const projectTasks = pgTable(
  "project_tasks",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    projectId: uuid("project_id")
      .notNull()
      .references(() => projects.id, { onDelete: "cascade" }),
    milestoneId: uuid("milestone_id").references(() => projectMilestones.id, {
      onDelete: "set null",
    }),
    title: text("title").notNull(),
    description: text("description"),
    status: varchar("status", { length: 50 }).default("todo").notNull(),
    dueDate: timestamp("due_date"),
    conversationId: uuid("conversation_id").references(
      (): AnyPgColumn => conversations.id,
      { onDelete: "set null" }
    ),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at")
      .defaultNow()
      .$onUpdate(() => new Date())
      .notNull(),
  },
  (table) => [
    index("project_tasks_projectId_idx").on(table.projectId),
    index("project_tasks_milestoneId_idx").on(table.milestoneId),
    index("project_tasks_conversationId_idx").on(table.conversationId),
  ]
);

export const userFacts = pgTable(
  "user_facts",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    category: text("category").notNull(),
    fact: text("fact").notNull(),
    confidence: real("confidence").default(0.8),
    source: text("source"),
    sourceId: uuid("source_id"),
    embedding: vector("embedding", { dimensions: 1536 }),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => [
    index("user_facts_userId_idx").on(table.userId),
    index("userFacts_embedding_idx").using(
      "hnsw",
      table.embedding.op("vector_cosine_ops")
    ),
  ]
);

// Phase 3: Agent System
export const agents = pgTable(
  "agents",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    name: text("name").notNull(),
    slug: text("slug").notNull(),
    description: text("description").notNull(),
    systemPrompt: text("system_prompt").notNull(),
    isStarter: boolean("is_starter").default(false).notNull(),
    icon: text("icon"),
    preferredModel: varchar("preferred_model", { length: 100 }),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at").defaultNow().notNull(),
    archivedAt: timestamp("archived_at"),
  },
  (table) => [
    index("agents_userId_idx").on(table.userId),
    unique("agents_userId_slug_idx").on(table.userId, table.slug),
  ]
);

export const agentExecutions = pgTable(
  "agent_executions",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    agentId: uuid("agent_id")
      .notNull()
      .references(() => agents.id, { onDelete: "cascade" }),
    conversationId: uuid("conversation_id").references(
      () => conversations.id,
      { onDelete: "set null" }
    ),
    projectId: uuid("project_id").references((): AnyPgColumn => projects.id, {
      onDelete: "set null",
    }),
    task: text("task").notNull(),
    result: text("result"),
    status: text("status").default("pending").notNull(),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    completedAt: timestamp("completed_at"),
  },
  (table) => [
    index("agent_executions_userId_idx").on(table.userId),
    index("agent_executions_agentId_idx").on(table.agentId),
    index("agent_executions_projectId_idx").on(table.projectId),
  ]
);

export const agentFeedback = pgTable(
  "agent_feedback",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    agentId: uuid("agent_id")
      .notNull()
      .references(() => agents.id, { onDelete: "cascade" }),
    executionId: uuid("execution_id").references(
      () => agentExecutions.id,
      { onDelete: "set null" }
    ),
    rating: text("rating").notNull(),
    correction: text("correction"),
    createdAt: timestamp("created_at").defaultNow().notNull(),
  },
  (table) => [
    index("agent_feedback_agentId_idx").on(table.agentId),
    index("agent_feedback_userId_idx").on(table.userId),
  ]
);

export const agentVersions = pgTable(
  "agent_versions",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    agentId: uuid("agent_id")
      .notNull()
      .references(() => agents.id, { onDelete: "cascade" }),
    version: integer("version").notNull(),
    systemPrompt: text("system_prompt").notNull(),
    changeSource: text("change_source").notNull(),
    changeSummary: text("change_summary"),
    createdAt: timestamp("created_at").defaultNow().notNull(),
  },
  (table) => [
    index("agent_versions_agentId_idx").on(table.agentId),
    unique("agent_versions_agentId_version_unique").on(
      table.agentId,
      table.version
    ),
  ]
);

// Phase 6: API Key Management & Usage Tracking
export const userApiKeys = pgTable(
  "user_api_keys",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    provider: varchar("provider", { length: 50 }).notNull(),
    encryptedKey: text("encrypted_key").notNull(),
    isValid: boolean("is_valid").default(true),
    lastValidatedAt: timestamp("last_validated_at"),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => [
    index("user_api_keys_userId_idx").on(table.userId),
    unique("user_api_keys_userId_provider_idx").on(table.userId, table.provider),
  ]
);

export const tokenUsage = pgTable(
  "token_usage",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    conversationId: uuid("conversation_id").references(
      () => conversations.id,
      { onDelete: "set null" }
    ),
    provider: varchar("provider", { length: 50 }).notNull(),
    model: varchar("model", { length: 100 }).notNull(),
    inputTokens: integer("input_tokens").notNull().default(0),
    outputTokens: integer("output_tokens").notNull().default(0),
    estimatedCostCents: integer("estimated_cost_cents").notNull().default(0),
    createdAt: timestamp("created_at").defaultNow().notNull(),
  },
  (table) => [
    index("token_usage_userId_idx").on(table.userId),
    index("token_usage_userId_createdAt_idx").on(table.userId, table.createdAt),
  ]
);

export const conversationRelations = relations(conversations, ({ one, many }) => ({
  user: one(user, {
    fields: [conversations.userId],
    references: [user.id],
  }),
  parent: one(conversations, {
    fields: [conversations.parentId],
    references: [conversations.id],
    relationName: "conversationParent",
  }),
  children: many(conversations, { relationName: "conversationParent" }),
  project: one(projects, {
    fields: [conversations.projectId],
    references: [projects.id],
  }),
}));

export const memoryRelations = relations(memories, ({ one }) => ({
  user: one(user, {
    fields: [memories.userId],
    references: [user.id],
  }),
  conversation: one(conversations, {
    fields: [memories.conversationId],
    references: [conversations.id],
  }),
}));

export const documentRelations = relations(documents, ({ one, many }) => ({
  user: one(user, {
    fields: [documents.userId],
    references: [user.id],
  }),
  projectDocuments: many(projectDocuments),
}));

export const userFactRelations = relations(userFacts, ({ one }) => ({
  user: one(user, {
    fields: [userFacts.userId],
    references: [user.id],
  }),
}));

export const agentFeedbackRelations = relations(agentFeedback, ({ one }) => ({
  user: one(user, {
    fields: [agentFeedback.userId],
    references: [user.id],
  }),
  agent: one(agents, {
    fields: [agentFeedback.agentId],
    references: [agents.id],
  }),
  agentExecution: one(agentExecutions, {
    fields: [agentFeedback.executionId],
    references: [agentExecutions.id],
  }),
}));

export const agentVersionRelations = relations(agentVersions, ({ one }) => ({
  agent: one(agents, {
    fields: [agentVersions.agentId],
    references: [agents.id],
  }),
}));

export const userApiKeysRelations = relations(userApiKeys, ({ one }) => ({
  user: one(user, {
    fields: [userApiKeys.userId],
    references: [user.id],
  }),
}));

export const tokenUsageRelations = relations(tokenUsage, ({ one }) => ({
  user: one(user, {
    fields: [tokenUsage.userId],
    references: [user.id],
  }),
  conversation: one(conversations, {
    fields: [tokenUsage.conversationId],
    references: [conversations.id],
  }),
}));

export const agentRelations = relations(agents, ({ one, many }) => ({
  user: one(user, {
    fields: [agents.userId],
    references: [user.id],
  }),
  feedback: many(agentFeedback),
  versions: many(agentVersions),
}));

export const agentExecutionRelations = relations(agentExecutions, ({ one }) => ({
  user: one(user, {
    fields: [agentExecutions.userId],
    references: [user.id],
  }),
  agent: one(agents, {
    fields: [agentExecutions.agentId],
    references: [agents.id],
  }),
  conversation: one(conversations, {
    fields: [agentExecutions.conversationId],
    references: [conversations.id],
  }),
  project: one(projects, {
    fields: [agentExecutions.projectId],
    references: [projects.id],
  }),
}));

// Phase 8: Project relations
export const projectRelations = relations(projects, ({ one, many }) => ({
  user: one(user, {
    fields: [projects.userId],
    references: [user.id],
  }),
  projectDocuments: many(projectDocuments),
  projectLinks: many(projectLinks),
  projectMilestones: many(projectMilestones),
  projectTasks: many(projectTasks),
  conversations: many(conversations),
  agentExecutions: many(agentExecutions),
}));

export const projectDocumentRelations = relations(projectDocuments, ({ one }) => ({
  project: one(projects, {
    fields: [projectDocuments.projectId],
    references: [projects.id],
  }),
  document: one(documents, {
    fields: [projectDocuments.documentId],
    references: [documents.id],
  }),
}));

export const projectLinkRelations = relations(projectLinks, ({ one }) => ({
  project: one(projects, {
    fields: [projectLinks.projectId],
    references: [projects.id],
  }),
}));

export const projectMilestoneRelations = relations(projectMilestones, ({ one, many }) => ({
  project: one(projects, {
    fields: [projectMilestones.projectId],
    references: [projects.id],
  }),
  tasks: many(projectTasks),
}));

export const projectTaskRelations = relations(projectTasks, ({ one }) => ({
  project: one(projects, {
    fields: [projectTasks.projectId],
    references: [projects.id],
  }),
  milestone: one(projectMilestones, {
    fields: [projectTasks.milestoneId],
    references: [projectMilestones.id],
  }),
  conversation: one(conversations, {
    fields: [projectTasks.conversationId],
    references: [conversations.id],
  }),
}));
